{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useState } from 'react';\nconst useProjectVisibility = (count, options) => {\n  _s();\n  const refs = useRef([]);\n  const [visibility, setVisibility] = useState(new Array(count).fill(false));\n  useEffect(() => {\n    const observers = refs.current.map((ref, index) => {\n      const observer = new IntersectionObserver(([entry]) => {\n        if (entry.isIntersecting) {\n          setVisibility(prevVisibility => {\n            const newVisibility = [...prevVisibility];\n            newVisibility[index] = true; // Set to true to ensure it only happens once\n            return newVisibility;\n          });\n          observer.unobserve(ref);\n        }\n      }, options);\n      if (ref) observer.observe(ref);\n      return observer;\n    });\n    return () => {\n      observers.forEach((observer, index) => {\n        if (refs.current[index]) observer.unobserve(refs.current[index]);\n      });\n    };\n  }, [options, count]);\n  return [refs, visibility];\n};\n_s(useProjectVisibility, \"IMrLp7qW5BxVVfOCI1qKjlMGZkU=\");\nexport default useProjectVisibility;","map":{"version":3,"names":["useEffect","useRef","useState","useProjectVisibility","count","options","_s","refs","visibility","setVisibility","Array","fill","observers","current","map","ref","index","observer","IntersectionObserver","entry","isIntersecting","prevVisibility","newVisibility","unobserve","observe","forEach"],"sources":["D:/abrar/New folder/New folder/web development/Complete Mern Development/myportfolio/src/Components/UseProjectVisibility.jsx"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\r\n\r\nconst useProjectVisibility = (count, options) => {\r\n  const refs = useRef([]);\r\n  const [visibility, setVisibility] = useState(new Array(count).fill(false));\r\n\r\n  useEffect(() => {\r\n    const observers = refs.current.map((ref, index) => {\r\n      const observer = new IntersectionObserver(([entry]) => {\r\n        if (entry.isIntersecting) {\r\n          setVisibility(prevVisibility => {\r\n            const newVisibility = [...prevVisibility];\r\n            newVisibility[index] = true; // Set to true to ensure it only happens once\r\n            return newVisibility;\r\n          });\r\n          observer.unobserve(ref);\r\n        }\r\n      }, options);\r\n\r\n      if (ref) observer.observe(ref);\r\n\r\n      return observer;\r\n    });\r\n\r\n    return () => {\r\n      observers.forEach((observer, index) => {\r\n        if (refs.current[index]) observer.unobserve(refs.current[index]);\r\n      });\r\n    };\r\n  }, [options, count]);\r\n\r\n  return [refs, visibility];\r\n};\r\n\r\nexport default useProjectVisibility;\r\n"],"mappings":";AAAA,SAASA,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAEnD,MAAMC,oBAAoB,GAAGA,CAACC,KAAK,EAAEC,OAAO,KAAK;EAAAC,EAAA;EAC/C,MAAMC,IAAI,GAAGN,MAAM,CAAC,EAAE,CAAC;EACvB,MAAM,CAACO,UAAU,EAAEC,aAAa,CAAC,GAAGP,QAAQ,CAAC,IAAIQ,KAAK,CAACN,KAAK,CAAC,CAACO,IAAI,CAAC,KAAK,CAAC,CAAC;EAE1EX,SAAS,CAAC,MAAM;IACd,MAAMY,SAAS,GAAGL,IAAI,CAACM,OAAO,CAACC,GAAG,CAAC,CAACC,GAAG,EAAEC,KAAK,KAAK;MACjD,MAAMC,QAAQ,GAAG,IAAIC,oBAAoB,CAAC,CAAC,CAACC,KAAK,CAAC,KAAK;QACrD,IAAIA,KAAK,CAACC,cAAc,EAAE;UACxBX,aAAa,CAACY,cAAc,IAAI;YAC9B,MAAMC,aAAa,GAAG,CAAC,GAAGD,cAAc,CAAC;YACzCC,aAAa,CAACN,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;YAC7B,OAAOM,aAAa;UACtB,CAAC,CAAC;UACFL,QAAQ,CAACM,SAAS,CAACR,GAAG,CAAC;QACzB;MACF,CAAC,EAAEV,OAAO,CAAC;MAEX,IAAIU,GAAG,EAAEE,QAAQ,CAACO,OAAO,CAACT,GAAG,CAAC;MAE9B,OAAOE,QAAQ;IACjB,CAAC,CAAC;IAEF,OAAO,MAAM;MACXL,SAAS,CAACa,OAAO,CAAC,CAACR,QAAQ,EAAED,KAAK,KAAK;QACrC,IAAIT,IAAI,CAACM,OAAO,CAACG,KAAK,CAAC,EAAEC,QAAQ,CAACM,SAAS,CAAChB,IAAI,CAACM,OAAO,CAACG,KAAK,CAAC,CAAC;MAClE,CAAC,CAAC;IACJ,CAAC;EACH,CAAC,EAAE,CAACX,OAAO,EAAED,KAAK,CAAC,CAAC;EAEpB,OAAO,CAACG,IAAI,EAAEC,UAAU,CAAC;AAC3B,CAAC;AAACF,EAAA,CA9BIH,oBAAoB;AAgC1B,eAAeA,oBAAoB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}